// Code generated by ogen, DO NOT EDIT.

package client

import (
	"context"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.37.0"
	"go.opentelemetry.io/otel/trace"
)

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// AddData invokes addData operation.
	//
	// Submit GPS location data for carrier vehicles. Each data point must include vehicle ID,
	// coordinates, timestamp, heading, and speed.
	//
	// POST /v1/carrier/{carrierId}/gps-data
	AddData(ctx context.Context, request []GpsData, params AddDataParams) (AddDataRes, error)
	// AddTrips invokes addTrips operation.
	//
	// Submit trip data for carrier vehicles. Each trip must include vehicle ID, trip number, and legs
	// with start/end coordinates and arrival windows.
	//
	// POST /v1/carrier/{carrierId}/trips
	AddTrips(ctx context.Context, request []Trip, params AddTripsParams) (AddTripsRes, error)
	// CancelShipmentByOrderNumber invokes cancelShipmentByOrderNumber operation.
	//
	// Cancels an existing shipment using its order number (PRO number). Shipments can only be cancelled
	// when they are in a cancellable state (e.g., before pickup).
	//
	// PUT /v1/shipper/shipment/{orderNumber}/cancel
	CancelShipmentByOrderNumber(ctx context.Context, params CancelShipmentByOrderNumberParams) (CancelShipmentByOrderNumberRes, error)
	// ConfirmShipmentByOrderNumber invokes confirmShipmentByOrderNumber operation.
	//
	// Confirms an existing shipment using its order number (PRO number).
	// Moves the shipment from INITIALIZED to CONFIRMED state.
	// **Prerequisites:**
	// - The order must be in INITIALIZED state
	// - The order must have an associated quote
	// **Validation Requirements:**
	// The following fields are validated during confirmation. If any are missing or invalid,
	// the shipment will remain in INITIALIZED state.
	// *Address Fields (required on BOTH pickup and delivery addresses):*
	// - `name` - Location/company name
	// - `address1` - Street address
	// - `zipCode` - ZIP code
	// - `contactPerson` - Contact name
	// - `phoneNumber` - Contact phone (E.164 format, e.g., "+15551234567")
	// - `openTime` - Opening time in HH:mm format (defaults to "10:00")
	// - `closeTime` - Closing time in HH:mm format (defaults to "16:00")
	// *Order Fields:*
	// - `description` - Must not be empty
	// - `totalPalletCount` - Must be between 1 and 51
	// - `totalPoundsWeight` - Must be between 1 and 2,500 lbs per pallet
	// *Order Component Fields (per component):*
	// - `palletCount` - Must be at least 1
	// - `poundsWeight` - Must be between 1 and 2,500 lbs per pallet
	// - `palletDimensions` - Must be valid dimensions within limits (subject to change, these are
	// configurable):
	// - Standard: max 60×52×94 inches (L×W×H) - pallets exceeding these are charged as oversized
	// - Oversized maximum: 95×95×96 inches - no pallet can exceed this
	// - With liftgate: max 62×62×94 inches
	// *Component Totals:*
	// - Sum of component `palletCount` must equal order `totalPalletCount`
	// - Sum of component `poundsWeight` must equal order `totalPoundsWeight`.
	//
	// PUT /v1/shipper/shipment/{orderNumber}/confirm
	ConfirmShipmentByOrderNumber(ctx context.Context, params ConfirmShipmentByOrderNumberParams) (ConfirmShipmentByOrderNumberRes, error)
	// CreateShipment invokes createShipment operation.
	//
	// Creates a new shipment order. Optionally reference a previously generated quote. The shipment must
	// be confirmed after creation.
	// **Note:** The `companyId` is automatically extracted from your API key.
	// You do not need to provide this value in the request body.
	// For M2M (machine-to-machine) integrations, no user context is required.
	//
	// POST /v1/shipper/shipment
	CreateShipment(ctx context.Context, request *ExternalCreateShipmentRequest) (CreateShipmentRes, error)
	// GetCarrierApiConfig invokes getCarrierApiConfig operation.
	//
	// Retrieves the API configuration for a carrier including company name, API version, and available
	// endpoints.
	//
	// GET /v1/carrier/{carrierId}
	GetCarrierApiConfig(ctx context.Context, params GetCarrierApiConfigParams) (GetCarrierApiConfigRes, error)
	// GetDocumentByOrderNumber invokes getDocumentByOrderNumber operation.
	//
	// Retrieves a download link for a shipment document using the order number (PRO number). Supported
	// document types: BILL_OF_LADING, INVOICE, SHIPPING_LABEL.
	//
	// GET /v1/shipper/shipment/{orderNumber}/document/{documentType}
	GetDocumentByOrderNumber(ctx context.Context, params GetDocumentByOrderNumberParams) (GetDocumentByOrderNumberRes, error)
	// GetInvoice invokes getInvoice operation.
	//
	// Retrieves the itemized invoice for a delivered shipment.
	// The invoice includes all charges (base freight, accessorials) and line items.
	// **Note:** This endpoint is only available for shipments in DELIVERED state.
	// Invoices are finalized when a shipment is delivered.
	//
	// GET /v1/shipper/shipment/{orderNumber}/invoice
	GetInvoice(ctx context.Context, params GetInvoiceParams) (GetInvoiceRes, error)
	// GetJobs invokes getJobs operation.
	//
	// Retrieves jobs (offers with order data) for a carrier. Filter by active status and time range.
	//
	// GET /v1/carrier/{carrierId}/jobs
	GetJobs(ctx context.Context, params GetJobsParams) (GetJobsRes, error)
	// GetQuote invokes getQuote operation.
	//
	// Retrieves an existing quote by its unique identifier. Quotes are valid for 2 days from creation.
	//
	// GET /v1/shipper/quote/{quoteId}
	GetQuote(ctx context.Context, params GetQuoteParams) (GetQuoteRes, error)
	// GetShipmentByOrderNumber invokes getShipmentByOrderNumber operation.
	//
	// Retrieves a shipment by its order number (PRO number). The order number is a 5-character
	// alphanumeric code (e.g., ZKYQ5) that uniquely identifies the shipment.
	//
	// GET /v1/shipper/shipment/{orderNumber}
	GetShipmentByOrderNumber(ctx context.Context, params GetShipmentByOrderNumberParams) (GetShipmentByOrderNumberRes, error)
	// GetToken invokes getToken operation.
	//
	// Exchange client credentials for an access token.
	// The returned token includes scopes that determine API access:
	// - `shipper` scope grants access to `/v1/shipper/**` endpoints
	// - `carrier` scope grants access to `/v1/carrier/**` endpoints
	// - Partners with both scopes can access both APIs with a single token
	// The returned token should be included in subsequent API requests as a Bearer token
	// in the authorization header: `authorization: Bearer {access_token}`
	// Tokens are valid for the duration specified in `expires_in` (seconds).
	// We recommend caching tokens and refreshing them before expiration.
	//
	// POST /v1/auth/token
	GetToken(ctx context.Context, request *TokenRequest) (GetTokenRes, error)
	// RequestQuote invokes requestQuote operation.
	//
	// Generates a price quote for a shipment based on origin, destination, and cargo details. The quote
	// is valid for 2 days.
	// **Note:** The `companyId` is automatically extracted from your API key.
	// You do not need to provide this value in the request body.
	// For M2M (machine-to-machine) integrations, no user context is required.
	//
	// POST /v1/shipper/quote
	RequestQuote(ctx context.Context, request *ExternalRequestQuoteRequest) (RequestQuoteRes, error)
	// TrackShipmentByOrderNumber invokes trackShipmentByOrderNumber operation.
	//
	// Retrieves tracking information for a shipment by its order number (PRO number). Returns status and
	// estimated/actual pickup and delivery dates.
	//
	// GET /v1/shipper/shipment/{orderNumber}/tracking
	TrackShipmentByOrderNumber(ctx context.Context, params TrackShipmentByOrderNumberParams) (TrackShipmentByOrderNumberRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	baseClient
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// AddData invokes addData operation.
//
// Submit GPS location data for carrier vehicles. Each data point must include vehicle ID,
// coordinates, timestamp, heading, and speed.
//
// POST /v1/carrier/{carrierId}/gps-data
func (c *Client) AddData(ctx context.Context, request []GpsData, params AddDataParams) (AddDataRes, error) {
	res, err := c.sendAddData(ctx, request, params)
	return res, err
}

func (c *Client) sendAddData(ctx context.Context, request []GpsData, params AddDataParams) (res AddDataRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addData"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/carrier/{carrierId}/gps-data"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AddDataOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/carrier/"
	{
		// Encode "carrierId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "carrierId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CarrierId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/gps-data"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddDataRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddDataResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddTrips invokes addTrips operation.
//
// Submit trip data for carrier vehicles. Each trip must include vehicle ID, trip number, and legs
// with start/end coordinates and arrival windows.
//
// POST /v1/carrier/{carrierId}/trips
func (c *Client) AddTrips(ctx context.Context, request []Trip, params AddTripsParams) (AddTripsRes, error) {
	res, err := c.sendAddTrips(ctx, request, params)
	return res, err
}

func (c *Client) sendAddTrips(ctx context.Context, request []Trip, params AddTripsParams) (res AddTripsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addTrips"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/carrier/{carrierId}/trips"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AddTripsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/carrier/"
	{
		// Encode "carrierId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "carrierId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CarrierId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/trips"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddTripsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddTripsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CancelShipmentByOrderNumber invokes cancelShipmentByOrderNumber operation.
//
// Cancels an existing shipment using its order number (PRO number). Shipments can only be cancelled
// when they are in a cancellable state (e.g., before pickup).
//
// PUT /v1/shipper/shipment/{orderNumber}/cancel
func (c *Client) CancelShipmentByOrderNumber(ctx context.Context, params CancelShipmentByOrderNumberParams) (CancelShipmentByOrderNumberRes, error) {
	res, err := c.sendCancelShipmentByOrderNumber(ctx, params)
	return res, err
}

func (c *Client) sendCancelShipmentByOrderNumber(ctx context.Context, params CancelShipmentByOrderNumberParams) (res CancelShipmentByOrderNumberRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("cancelShipmentByOrderNumber"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/v1/shipper/shipment/{orderNumber}/cancel"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CancelShipmentByOrderNumberOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/shipper/shipment/"
	{
		// Encode "orderNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "orderNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrderNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/cancel"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCancelShipmentByOrderNumberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfirmShipmentByOrderNumber invokes confirmShipmentByOrderNumber operation.
//
// Confirms an existing shipment using its order number (PRO number).
// Moves the shipment from INITIALIZED to CONFIRMED state.
// **Prerequisites:**
// - The order must be in INITIALIZED state
// - The order must have an associated quote
// **Validation Requirements:**
// The following fields are validated during confirmation. If any are missing or invalid,
// the shipment will remain in INITIALIZED state.
// *Address Fields (required on BOTH pickup and delivery addresses):*
// - `name` - Location/company name
// - `address1` - Street address
// - `zipCode` - ZIP code
// - `contactPerson` - Contact name
// - `phoneNumber` - Contact phone (E.164 format, e.g., "+15551234567")
// - `openTime` - Opening time in HH:mm format (defaults to "10:00")
// - `closeTime` - Closing time in HH:mm format (defaults to "16:00")
// *Order Fields:*
// - `description` - Must not be empty
// - `totalPalletCount` - Must be between 1 and 51
// - `totalPoundsWeight` - Must be between 1 and 2,500 lbs per pallet
// *Order Component Fields (per component):*
// - `palletCount` - Must be at least 1
// - `poundsWeight` - Must be between 1 and 2,500 lbs per pallet
// - `palletDimensions` - Must be valid dimensions within limits (subject to change, these are
// configurable):
// - Standard: max 60×52×94 inches (L×W×H) - pallets exceeding these are charged as oversized
// - Oversized maximum: 95×95×96 inches - no pallet can exceed this
// - With liftgate: max 62×62×94 inches
// *Component Totals:*
// - Sum of component `palletCount` must equal order `totalPalletCount`
// - Sum of component `poundsWeight` must equal order `totalPoundsWeight`.
//
// PUT /v1/shipper/shipment/{orderNumber}/confirm
func (c *Client) ConfirmShipmentByOrderNumber(ctx context.Context, params ConfirmShipmentByOrderNumberParams) (ConfirmShipmentByOrderNumberRes, error) {
	res, err := c.sendConfirmShipmentByOrderNumber(ctx, params)
	return res, err
}

func (c *Client) sendConfirmShipmentByOrderNumber(ctx context.Context, params ConfirmShipmentByOrderNumberParams) (res ConfirmShipmentByOrderNumberRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("confirmShipmentByOrderNumber"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/v1/shipper/shipment/{orderNumber}/confirm"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ConfirmShipmentByOrderNumberOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/shipper/shipment/"
	{
		// Encode "orderNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "orderNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrderNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/confirm"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeConfirmShipmentByOrderNumberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateShipment invokes createShipment operation.
//
// Creates a new shipment order. Optionally reference a previously generated quote. The shipment must
// be confirmed after creation.
// **Note:** The `companyId` is automatically extracted from your API key.
// You do not need to provide this value in the request body.
// For M2M (machine-to-machine) integrations, no user context is required.
//
// POST /v1/shipper/shipment
func (c *Client) CreateShipment(ctx context.Context, request *ExternalCreateShipmentRequest) (CreateShipmentRes, error) {
	res, err := c.sendCreateShipment(ctx, request)
	return res, err
}

func (c *Client) sendCreateShipment(ctx context.Context, request *ExternalCreateShipmentRequest) (res CreateShipmentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createShipment"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/shipper/shipment"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateShipmentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/shipper/shipment"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateShipmentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateShipmentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCarrierApiConfig invokes getCarrierApiConfig operation.
//
// Retrieves the API configuration for a carrier including company name, API version, and available
// endpoints.
//
// GET /v1/carrier/{carrierId}
func (c *Client) GetCarrierApiConfig(ctx context.Context, params GetCarrierApiConfigParams) (GetCarrierApiConfigRes, error) {
	res, err := c.sendGetCarrierApiConfig(ctx, params)
	return res, err
}

func (c *Client) sendGetCarrierApiConfig(ctx context.Context, params GetCarrierApiConfigParams) (res GetCarrierApiConfigRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCarrierApiConfig"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/carrier/{carrierId}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetCarrierApiConfigOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/carrier/"
	{
		// Encode "carrierId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "carrierId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CarrierId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetCarrierApiConfigResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDocumentByOrderNumber invokes getDocumentByOrderNumber operation.
//
// Retrieves a download link for a shipment document using the order number (PRO number). Supported
// document types: BILL_OF_LADING, INVOICE, SHIPPING_LABEL.
//
// GET /v1/shipper/shipment/{orderNumber}/document/{documentType}
func (c *Client) GetDocumentByOrderNumber(ctx context.Context, params GetDocumentByOrderNumberParams) (GetDocumentByOrderNumberRes, error) {
	res, err := c.sendGetDocumentByOrderNumber(ctx, params)
	return res, err
}

func (c *Client) sendGetDocumentByOrderNumber(ctx context.Context, params GetDocumentByOrderNumberParams) (res GetDocumentByOrderNumberRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDocumentByOrderNumber"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/shipper/shipment/{orderNumber}/document/{documentType}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetDocumentByOrderNumberOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/shipper/shipment/"
	{
		// Encode "orderNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "orderNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrderNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/document/"
	{
		// Encode "documentType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "documentType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.DocumentType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDocumentByOrderNumberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetInvoice invokes getInvoice operation.
//
// Retrieves the itemized invoice for a delivered shipment.
// The invoice includes all charges (base freight, accessorials) and line items.
// **Note:** This endpoint is only available for shipments in DELIVERED state.
// Invoices are finalized when a shipment is delivered.
//
// GET /v1/shipper/shipment/{orderNumber}/invoice
func (c *Client) GetInvoice(ctx context.Context, params GetInvoiceParams) (GetInvoiceRes, error) {
	res, err := c.sendGetInvoice(ctx, params)
	return res, err
}

func (c *Client) sendGetInvoice(ctx context.Context, params GetInvoiceParams) (res GetInvoiceRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getInvoice"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/shipper/shipment/{orderNumber}/invoice"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetInvoiceOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/shipper/shipment/"
	{
		// Encode "orderNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "orderNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrderNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/invoice"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetInvoiceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetJobs invokes getJobs operation.
//
// Retrieves jobs (offers with order data) for a carrier. Filter by active status and time range.
//
// GET /v1/carrier/{carrierId}/jobs
func (c *Client) GetJobs(ctx context.Context, params GetJobsParams) (GetJobsRes, error) {
	res, err := c.sendGetJobs(ctx, params)
	return res, err
}

func (c *Client) sendGetJobs(ctx context.Context, params GetJobsParams) (res GetJobsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getJobs"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/carrier/{carrierId}/jobs"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetJobsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/carrier/"
	{
		// Encode "carrierId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "carrierId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CarrierId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/jobs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "activeOnly" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "activeOnly",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ActiveOnly.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "startTime" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "startTime",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StartTime.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "endTime" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "endTime",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EndTime.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetJobsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetQuote invokes getQuote operation.
//
// Retrieves an existing quote by its unique identifier. Quotes are valid for 2 days from creation.
//
// GET /v1/shipper/quote/{quoteId}
func (c *Client) GetQuote(ctx context.Context, params GetQuoteParams) (GetQuoteRes, error) {
	res, err := c.sendGetQuote(ctx, params)
	return res, err
}

func (c *Client) sendGetQuote(ctx context.Context, params GetQuoteParams) (res GetQuoteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getQuote"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/shipper/quote/{quoteId}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetQuoteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/shipper/quote/"
	{
		// Encode "quoteId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "quoteId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.QuoteId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetQuoteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetShipmentByOrderNumber invokes getShipmentByOrderNumber operation.
//
// Retrieves a shipment by its order number (PRO number). The order number is a 5-character
// alphanumeric code (e.g., ZKYQ5) that uniquely identifies the shipment.
//
// GET /v1/shipper/shipment/{orderNumber}
func (c *Client) GetShipmentByOrderNumber(ctx context.Context, params GetShipmentByOrderNumberParams) (GetShipmentByOrderNumberRes, error) {
	res, err := c.sendGetShipmentByOrderNumber(ctx, params)
	return res, err
}

func (c *Client) sendGetShipmentByOrderNumber(ctx context.Context, params GetShipmentByOrderNumberParams) (res GetShipmentByOrderNumberRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getShipmentByOrderNumber"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/shipper/shipment/{orderNumber}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetShipmentByOrderNumberOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/shipper/shipment/"
	{
		// Encode "orderNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "orderNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrderNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetShipmentByOrderNumberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetToken invokes getToken operation.
//
// Exchange client credentials for an access token.
// The returned token includes scopes that determine API access:
// - `shipper` scope grants access to `/v1/shipper/**` endpoints
// - `carrier` scope grants access to `/v1/carrier/**` endpoints
// - Partners with both scopes can access both APIs with a single token
// The returned token should be included in subsequent API requests as a Bearer token
// in the authorization header: `authorization: Bearer {access_token}`
// Tokens are valid for the duration specified in `expires_in` (seconds).
// We recommend caching tokens and refreshing them before expiration.
//
// POST /v1/auth/token
func (c *Client) GetToken(ctx context.Context, request *TokenRequest) (GetTokenRes, error) {
	res, err := c.sendGetToken(ctx, request)
	return res, err
}

func (c *Client) sendGetToken(ctx context.Context, request *TokenRequest) (res GetTokenRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getToken"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/auth/token"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetTokenOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/auth/token"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetTokenRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RequestQuote invokes requestQuote operation.
//
// Generates a price quote for a shipment based on origin, destination, and cargo details. The quote
// is valid for 2 days.
// **Note:** The `companyId` is automatically extracted from your API key.
// You do not need to provide this value in the request body.
// For M2M (machine-to-machine) integrations, no user context is required.
//
// POST /v1/shipper/quote
func (c *Client) RequestQuote(ctx context.Context, request *ExternalRequestQuoteRequest) (RequestQuoteRes, error) {
	res, err := c.sendRequestQuote(ctx, request)
	return res, err
}

func (c *Client) sendRequestQuote(ctx context.Context, request *ExternalRequestQuoteRequest) (res RequestQuoteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("requestQuote"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/shipper/quote"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, RequestQuoteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/shipper/quote"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRequestQuoteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRequestQuoteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TrackShipmentByOrderNumber invokes trackShipmentByOrderNumber operation.
//
// Retrieves tracking information for a shipment by its order number (PRO number). Returns status and
// estimated/actual pickup and delivery dates.
//
// GET /v1/shipper/shipment/{orderNumber}/tracking
func (c *Client) TrackShipmentByOrderNumber(ctx context.Context, params TrackShipmentByOrderNumberParams) (TrackShipmentByOrderNumberRes, error) {
	res, err := c.sendTrackShipmentByOrderNumber(ctx, params)
	return res, err
}

func (c *Client) sendTrackShipmentByOrderNumber(ctx context.Context, params TrackShipmentByOrderNumberParams) (res TrackShipmentByOrderNumberRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("trackShipmentByOrderNumber"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/shipper/shipment/{orderNumber}/tracking"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TrackShipmentByOrderNumberOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/shipper/shipment/"
	{
		// Encode "orderNumber" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "orderNumber",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrderNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tracking"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTrackShipmentByOrderNumberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
